// Code generated by protoc-gen-grpc-sarama. DO NOT EDIT.

package pb

import (
	"errors"

	"github.com/Shopify/sarama"
	"google.golang.org/protobuf/proto"
	"github.com/justin0u0/protoc-gen-grpc-sarama/pkg/saramakit"
)

type VideoStreamHandlers struct {
	*HandleVideoCreatedHandler
}

func NewVideoStreamHandlers(server VideoStreamServer, logger saramakit.Logger) *VideoStreamHandlers {
	return &VideoStreamHandlers{
		HandleVideoCreatedHandler: &HandleVideoCreatedHandler{
			server:      server,
			unmarshaler: &proto.UnmarshalOptions{},
			logger:      logger.With("HandlerName", "HandleVideoCreatedHandler"),
		},
	}
}

type HandleVideoCreatedHandler struct {
	server      VideoStreamServer
	unmarshaler *proto.UnmarshalOptions
	logger      saramakit.Logger
}

var _ sarama.ConsumerGroupHandler = (*HandleVideoCreatedHandler)(nil)

func (h *HandleVideoCreatedHandler) Setup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleVideoCreatedHandler) Cleanup(sarama.ConsumerGroupSession) error {
	return nil
}

func (h *HandleVideoCreatedHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var req HandleVideoCreatedRequest

		if err := h.unmarshaler.Unmarshal(msg.Value, &req); err != nil {
			// unretryable failure, skip and consume the message
			h.logger.Error("failed to unmarshal message", err)

			continue
		}

		if _, err := h.server.HandleVideoCreated(sess.Context(), &req); err != nil {
			var e saramakit.HandlerError

			if ok := errors.As(err, &e); ok && e.Retry {
				h.logger.Error("failed to handle the message and the error is retryable", err)

				return nil
			}
			h.logger.Error("failed to handle the message and the error is unretryable", err)
		}

		// mark message as completed
		sess.MarkMessage(msg, "")
	}

	return nil
}
